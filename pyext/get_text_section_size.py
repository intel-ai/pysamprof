import subprocess
import re
import os
import sys
import tempfile

if sys.platform == 'win32':
    def _call_dumpbin(objPath, *args):
        handle, tempPath = tempfile.mkstemp('.dump-out')
        os.close(handle)
        try:
            proc = subprocess.Popen(['dumpbin'] + list(args) +['/out:%s' % tempPath, objPath],
                    stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
            out, _ = proc.communicate()
            if proc.returncode != 0:
                sys.exit('dumpbin errored out:\n%s' % out)
            with open(tempPath) as inp:
                return inp.read()
        finally:
            os.remove(tempPath)

    def get_section_size(objPath):
        # first find exact .text section name - they differ for different versions of MSVC
        summary = _call_dumpbin(objPath, '/summary')
        try:
            section_name = re.search(r'\s+(\.text[^\s]+)\s*$', summary, re.MULTILINE).group(1)
        except AttributeError:
            sys.exit('Cannot find full ".text" section name')
            
        out = _call_dumpbin(objPath, '/section:%s' % section_name.strip())
        found = re.findall(r'^\s*([0-9a-fA-F]+)\s*size of raw data\s*$', out, re.MULTILINE)

        try:
            sectionSize = int(found[0])
        except (ValueError, IndexError) as ex:
            sys.exit('dumpbin gave bad output (error: %r):\n%s' % (ex, out))

        return sectionSize
else:
    def get_section_size(objPath):
        try:
            out = subprocess.check_output(['objdump', '-h', objPath], stderr=subprocess.STDOUT).decode('utf8')
        except subprocess.CalledProcessError as ex:
            sys.exit('objdump errored out:\n%s' % ex.output)

        try:
            found = re.search(r'\.text\s+([0-9a-fA-F]+)\s+', out).group(1)
            sectionSize = int(found, 16)
        except (AttributeError, ValueError):
            sys.exit('cannot find .text section size for "%s". section: %s' % (objPath, out))
        return sectionSize

def main(objPath, headerTarget, defineName):
    sectionSize = get_section_size(objPath)

    contents = '\n'.join(['// Generated by %s from %s' % (sys.argv[0], objPath),
                          '#define %s %s' % (defineName, hex(sectionSize)),
                          ''])
    try:
        with open(headerTarget, 'r') as header:
            old_contents = header.read()
    except IOError:
        pass
    else:
        if contents == old_contents:
            print('%s is already up-to-date' % headerTarget)
            return
    with open(headerTarget, 'w') as header:
        header.write(contents)

if __name__ == '__main__':
    try:
        (objPath, headerTarget, defineName) = sys.argv[1:]
    except ValueError:
        sys.exit('Usage: %s obj-to-get-.text-from header-to-make.h DEFINE_NAME' % sys.argv[0])
    main(objPath, headerTarget, defineName)

